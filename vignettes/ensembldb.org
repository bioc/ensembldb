#+TITLE: Generating and using Ensembl based annotation packages
#+AUTHOR:    Johannes Rainer
#+EMAIL:     johannes.rainer@eurac.edu
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: ^:{} toc:nil
#+PROPERTY: exports code
#+PROPERTY: session *R*

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+latex: %\VignetteIndexEntry{Generating an using Ensembl based annotation packages}
#+latex: %\VignetteKeywords{annotation, database}
#+latex: %\VignetteDepends{ensembldb,EnsDb.Hsapiens.v75}
#+latex: %\VignettePackage{ensembldb}
#+latex: %\VignetteEngine{knitr::knitr}

#+BEGIN_HTML
---
title: "Generating an using Ensembl based annotation packages"
graphics: yes
output:
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Generating an using Ensembl based annotation packages}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{ensembldb,EnsDb.Hsapiens.v75,Gviz}
  %\VignettePackage{ensembldb}
  %\VignetteKeywords{annotation,database}
---
#+END_HTML


#+BEGIN_HTML
**Package**: `r Biocpkg("ensembldb")`<br />
**Authors**: `r packageDescription("ensembldb")[["Author"]] `<br />
**Modified**: 21 December, 2015<br />
**Compiled**: `r date()`
#+END_HTML


# #+NAME: style
# #+BEGIN_SRC R :ravel results='asis', echo=FALSE, eval=TRUE
# BiocStyle::latex()
# #+END_SRC


* How to export this to a =Rnw= vignette			   :noexport:

Use =ox-ravel= from the =orgmode-accessories= package to export this file to a =Rnw= file. After export edit the generated =Rnw= in the following way:

1) Delete all =\usepackage= commands.
2) Move the =<<style>>= code chunk before the =\begin{document}= and before =\author=.
3) Move all =%\Vignette...= lines at the start of the file (even before =\documentclass=).
4) Replace =\date= with =\date{Modified: 21 October, 2013. Compiled: \today}=
5) Eventually search for all problems with =texttt=, i.e. search for pattern ="==.

Note: use =:ravel= followed by the properties for the code chunk headers, e.g. =:ravel results='hide'=. Other options for knitr style options are:
+ =results=: ='hide'= (hides all output, not warnings or messages), ='asis'=, ='markup'= (the default).
+ =warning=: =TRUE= or =FALSE= whether warnings should be displayed.
+ =message=: =TRUE= or =FALSE=, same as above.
+ =include=: =TRUE= or =FALSE=, whether the output should be included into the final document (code is still evaluated).

* How to export this to a =Rmd= vignette			   :noexport:

Use =ox-ravel= to export this file as an R markdown file (=C-c C-e m
r=). That way we don't need to edit the resulting =Rmd= file.

* Introduction

The =ensembldb= package provides functions to create and use transcript centric
annotation databases/packages. The annotation for the databases are directly
fetched from Ensembl [fn:1] using their Perl API.  The functionality and data is
similar to that of the =TxDb= packages from the =GenomicFeatures= package, but,
in addition to retrieve all gene/transcript models and annotations from the
database, the =ensembldb= package provides also a filter framework allowing to
retrieve annotations for specific entries like genes encoded on a chromosome
region or transcript models of lincRNA genes.  In the databases, along with the
gene and transcript models and their chromosomal coordinates, additional
annotations including the gene name (symbol) and NCBI Entrezgene identifiers as
well as the gene and transcript biotypes are stored too (see Section
[[section.database.layout]] for the database layout and an overview of available
attributes/columns).

Another main goal of this package is to generate /versioned/ annotation
packages, i.e. annotation packages that are build for a specific Ensembl
release, and are also named according to that (e.g. =EnsDb.Hsapiens.v75= for
human gene definitions of the Ensembl code database version 75). This ensures
reproducibility, as it allows to load annotations from a specific Ensembl
release also if newer versions of annotation packages/releases are available. It
also allows to load multiple annotation packages at the same time in order to
e.g. compare gene models between Ensembl releases.

In the example below we load an Ensembl based annotation package for Homo
sapiens, Ensembl version 75. The connection to the database is bound to the
variable =EnsDb.Hsapiens.v75=.

#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  library(EnsDb.Hsapiens.v75)

  ## Making a "short cut"
  edb <- EnsDb.Hsapiens.v75
  ## print some informations for this package
  edb

  ## for what organism was the database generated?
  organism(edb)
#+END_SRC


* Using =ensembldb= annotation packages to retrieve specific annotations

The =ensembldb= package provides a set of filter objects allowing to specify
which entries should be fetched from the database. The complete list of filters,
which can be used individually or can be combined, is shown below (in
alphabetical order):

+ =ExonidFilter=: allows to filter the result based on the (Ensembl) exon
  identifiers.
+ =EntrezidFilter=: allows to filter results based on NCBI Entrezgene
  identifiers of the genes.
+ =GenebiotypeFilter=: allows to filter for the gene biotypes defined in the
  Ensembl database; use the =listGenebiotypes= method to list all available
  biotypes.
+ =GeneidFilter=: allows to filter based on the Ensembl gene IDs.
+ =GenenameFilter=: allows to filter based on the names (symbols) of the genes.
+ =GRangesFilter=: allows to retrieve all features (genes, transcripts or exons)
  that are either within (setting =condition = "within"=) or partially
  overlapping (=condition = "overlapping"=) the defined genomic
  region/range. Note that, depending on the called method (=genes=,
  =transcripts= or =exons=) the start and end coordinates of either the genes,
  transcripts or exons are used for the filter. For methods =exonsBy=, =cdsBy=
  and =txBy= the coordinates of =by= are used.
+ =SeqendFilter=: filter based on the chromosomal end coordinate of the exons,
  transcripts or genes (correspondingly set =feature = "exon"=, =feature = "tx"= or
  =feature = "gene"=).
+ =SeqnameFilter=: filter by the name of the chromosomes the genes are encoded
  on.
+ =SeqstartFilter=: filter based on the chromosomal start coordinates of the
  exons, transcripts or genes (correspondingly set =feature = "exon"=,
  =feature = "tx"= or =feature = "gene"=).
+ =SeqstrandFilter=: filter for the chromosome strand on which the genes are
  encoded.
+ =TxbiotypeFilter=: filter on the transcript biotype defined in Ensembl; use
  the =listTxbiotypes= method to list all available biotypes.
+ =TxidFilter=: filter on the Ensembl transcript identifiers.

Each of the filter classes can take a single value or a vector of values (with
the exception of the =SeqendFilter= and =SeqstartFilter=) for comparison. In
addition, it is possible to specify the /condition/ for the filter,
e.g. setting =condition= to = to retrieve all entries matching the filter value,
to != to negate the filter or setting =condition = "like"= to allow
partial matching. The =condition= parameter for =SeqendFilter= and
=SeqendFilter= can take the values = , >, >=, < and <= (since these
filters base on numeric values).

The =SeqnameFilter= and =GRangesFilter= support both UCSC and Ensembl chromosome
names (e.g. ="chrX"= for UCSC and ="X"= for Ensembl), internally, UCSC
chromosome names are mapped to Ensembl names. By default, all functions to
retrieve data from the database return Ensembl chromosome names, but by setting
the global option =ucscChromosomeNames= to =TRUE=
(i.e. =options(ucscChromosomeNames = TRUE)=) chromosome/seqnames are returned in
UCSC format.

A simple example would be to get all transcripts for the gene /BCL2L11/. To this
end we specify a =GenenameFilter= with the value ="BCL2L11"=. As a result we get
a =GRanges= object with =start=, =end=, =strand= and =seqname= of the =GRanges=
object being the start coordinate, end coordinate, chromosome name and strand
for the respective transcripts. All additional annotations are available as
metadata columns. Alternatively, by setting =return.type = "DataFrame"=, or
=return.type="data.frame"= the method would return a =DataFrame= object or
=data.frame=.

#+BEGIN_SRC R
  Tx <- transcripts(edb, filter=list(GenenameFilter("BCL2L11")))

  Tx

  ## as this is a GRanges object we can access e.g. the start coordinates with
  head(start(Tx))

  ## or extract the biotype with
  head(Tx$tx_biotype)
#+END_SRC

The parameter =columns= of the =exons=, =genes= and =transcripts= method allow
to specify which database attributes (columns) should be retrieved. Note that
these are not restricted to columns of the corresponding database table
(e.g. columns of database table /gene/ for =genes=). To get an overview of
database tables and available columns the function =listTables= can be used. The
method =listColumns= on the other hand lists columns for the specified database
table.

#+BEGIN_SRC R
  ## list all database tables along with their columns
  listTables(edb)

  ## list columns from a specific table
  listColumns(edb, "tx")
#+END_SRC

Thus, we could retrieve all transcripts of the biotype /nonsense_mediated_decay/
(which, according to the definitions by Ensembl are transcribed, but most likely
not translated in a protein, but rather degraded after transcription) along with
the name of the gene for each transcript. Note that we are changing here the
=return.type= to =DataFrame=, so the method will return a =DataFrame= with the
results instead of the default =GRanges=.

#+BEGIN_SRC R
  Tx <- transcripts(edb,
                    columns=c(listColumns(edb , "tx"), "gene_name"),
                    filter=TxbiotypeFilter("nonsense_mediated_decay"),
                    return.type="DataFrame")
  nrow(Tx)
  Tx
#+END_SRC

For protein coding transcripts, we can also specifically extract their coding
region. In the example below we extract the CDS for all transcripts encoded on
chromosome Y.

#+BEGIN_SRC R
  yCds <- cdsBy(edb, filter=SeqnameFilter("Y"))
  yCds
#+END_SRC

Using a =GRangesFilter= we can retrieve all features from the database that are
either within or overlapping with the specified genomic region. In the example
below we query all genes that are partially overlapping with a small region on
chromosome 11. The filter restricts to all genes for which either an exon or an
intron is partially overlapping with the region.

#+BEGIN_SRC R
  ## Define the filter
  grf <- GRangesFilter(GRanges("11", ranges=IRanges(114000000, 114000050),
                               strand="+"), condition="overlapping")

  ## Query genes:
  gn <- genes(edb, filter=grf)
  gn

  ## Next we retrieve all transcripts for that gene so that we can plot them.
  txs <- transcripts(edb, filter=GenenameFilter(gn$gene_name))
#+END_SRC

#+BEGIN_SRC R :ravel tx-for-zbtb16, message=FALSE, fig.align='center', fig.width=7.5, fig.height=5
  plot(3, 3, pch=NA, xlim=c(start(gn), end(gn)), ylim=c(0, length(txs)), yaxt="n", ylab="")
  ## Highlight the GRangesFilter region
  rect(xleft=start(grf), xright=end(grf), ybottom=0, ytop=length(txs), col="red", border="red")
  for(i in 1:length(txs)){
      current <- txs[i]
      rect(xleft=start(current), xright=end(current), ybottom=i-0.975, ytop=i-0.125, border="grey")
      text(start(current), y=i-0.5,pos=4, cex=0.75, labels=current$tx_id)
  }

#+END_SRC

As we can see, 4 transcripts of the gene ZBTB16 are also overlapping the
region. Below we fetch these 4 transcripts. Note, that a call to =exons= will
not return any features from the database, as no exon is overlapping with the
region.

#+BEGIN_SRC R
  transcripts(edb, filter=grf)
#+END_SRC

To get an overview of allowed/available gene and transcript biotype the
functions =listGenebiotypes= and =listTxbiotypes= can be used.

#+BEGIN_SRC R
  ## Get all gene biotypes from the database. The GenebiotypeFilter
  ## allows to filter on these values.
  listGenebiotypes(edb)

  ## Get all transcript biotypes from the database.
  listTxbiotypes(edb)
#+END_SRC

Data can be fetched in an analogous way using the =exons= and =genes=
methods. In the example below we retrieve =gene_name=, =entrezid= and the
=gene_biotype= of all genes in the database which names start with ="BCL2"=.

#+BEGIN_SRC R
  ## We're going to fetch all genes which names start with BCL. To this end
  ## we define a GenenameFilter with partial matching, i.e. condition "like"
  ## and a % for any character/string.
  BCLs <- genes(edb,
                columns=c("gene_name", "entrezid", "gene_biotype"),
                filter=list(GenenameFilter("BCL%", condition="like")),
                return.type="DataFrame")
  nrow(BCLs)
  BCLs
#+END_SRC

Sometimes it might be useful to know the length of genes or transcripts
(i.e. the total sum of nucleotides covered by their exons). Below we calculate
the mean length of transcripts from protein coding genes on chromosomes X and Y
as well as the average length of snoRNA, snRNA and rRNA transcripts encoded on
these chromosomes.

#+BEGIN_SRC R
  ## determine the average length of snRNA, snoRNA and rRNA genes encoded on
  ## chromosomes X and Y.
  mean(lengthOf(edb, of="tx",
                filter=list(GenebiotypeFilter(c("snRNA", "snoRNA", "rRNA")),
                    SeqnameFilter(c("X", "Y")))))

  ## determine the average length of protein coding genes encoded on the same
  ## chromosomes.
  mean(lengthOf(edb, of="tx",
                filter=list(GenebiotypeFilter("protein_coding"),
                    SeqnameFilter(c("X", "Y")))))
#+END_SRC

Not unexpectedly, transcripts of protein coding genes are longer than those of
snRNA, snoRNA or rRNA genes.


* Extracting gene/transcript/exon models for RNASeq feature counting

For the feature counting step of an RNAseq experiment, the gene or transcript
models (defined by the chromosomal start and end positions of their exons) have
to be known. To extract these from an Ensembl based annotation package, the
=exonsBy=, =genesBy= and =transcriptsBy= methods can be used in an analogous way
as in =TxDb= packages generated by the =GenomicFeatures= package.  However, the
=transcriptsBy= method does not, in contrast to the method in the
=GenomicFeatures= package, allow to return transcripts by ="cds"=. While the
annotation packages built by the =ensembldb= contain the chromosomal start and
end coordinates of the coding region (for protein coding genes) they do not
assign an ID to each CDS.

A simple use case is to retrieve all genes encoded on chromosomes X and Y from
the database.

#+BEGIN_SRC R
  TxByGns <- transcriptsBy(edb, by="gene",
                           filter=list(SeqnameFilter(c("X", "Y")))
                           )
  TxByGns
#+END_SRC

Since Ensembl contains also definitions of genes that are on chromosome variants
(supercontigs), it is advisable to specify the chromosome names for which the
gene models should be returned.

In a real use case, we might thus want to retrieve all genes encoded on the
/standard/ chromosomes. In addition it is advisable to use a =GeneidFilter= to
restrict to Ensembl genes only, as also /LRG/ (Locus Reference Genomic)
genes[fn:3] are defined in the database, which are partially redundant with
Ensembl genes.

#+BEGIN_SRC R :ravel eval=FALSE
  ## will just get exons for all genes on chromosomes 1 to 22, X and Y.
  ## Note: want to get rid of the "LRG" genes!!!
  EnsGenes <- exonsBy(edb, by="gene",
                      filter=list(SeqnameFilter(c(1:22, "X", "Y")),
                          GeneidFilter("ENSG%", "like")))
#+END_SRC

The code above returns a =GRangesList= that can be used directly as an input for
the =summarizeOverlaps= function from the =GenomicAlignments= package [fn:4].

Alternatively, the above =GRangesList= can be transformed to a =data.frame= in
/SAF/ format that can be used as an input to the =featureCounts= function of the
=Rsubread= package [fn:5].

#+BEGIN_SRC R :ravel eval=FALSE
  ## Transforming the GRangesList into a data.frame in SAF format
  EnsGenes.SAF <- toSAF(EnsGenes)

#+END_SRC

Note that the ID by which the =GRangesList= is split is used in the SAF
formatted =data.frame= as the =GeneID=. In the example below this would be the
Ensembl gene IDs, while the start, end coordinates (along with the strand and
chromosomes) are those of the the exons.

In addition, the =disjointExons= function (similar to the one defined in
=GenomicFeatures=) can be used to generate a =GRanges= of non-overlapping exon
parts which can be used in the =DEXSeq= package.

#+BEGIN_SRC R :ravel eval=FALSE
  ## Create a GRanges of non-overlapping exon parts.
  DJE <- disjointExons(edb,
                       filter=list(SeqnameFilter(c(1:22, "X", "Y")),
                            GeneidFilter("ENSG%", "like")))

#+END_SRC



* Retrieving sequences for gene/transcript/exon models

The methods to retrieve exons, transcripts and genes (i.e. =exons=,
=transcripts= and =genes=) return by default =GRanges= objects that can be used
to retrieve sequences using the =getSeq= method e.g. from BSgenome packages. The
basic workflow is thus identical to the one for =TxDb= packages, however, it is
not straight forward to identify the BSgenome package with the matching genomic
sequence. Most BSgenome packages are named according to the genome build
identifier used in UCSC which does not (always) match the genome build name used
by Ensembl.  Using the Ensembl version provided by the =EnsDb=, the correct
genomic sequence can however be retrieved easily from the =AnnotationHub= using
the =getGenomeFaFile=.

In the code block below we retrieve first the =FaFile= with the genomic DNA
sequence, extract the genomic start and end coordinates for all genes defined in
the package, subset to genes encoded on sequences available in the =FaFile= and
extract all of their sequences.  Note: these sequences represent the sequence
between the chromosomal start and end coordinates of the gene.

#+BEGIN_SRC R :ravel eval=FALSE
  library(EnsDb.Hsapiens.v75)
  library(Rsamtools)
  edb <- EnsDb.Hsapiens.v75

  ## Get the FaFile with the genomic sequence matching the Ensembl version
  ## using the AnnotationHub package.
  Dna <- getGenomeFaFile(edb)

  ## Get start/end coordinates of all genes.
  genes <- genes(edb)
  ## Subset to all genes that are encoded on chromosomes for which
  ## we do have DNA sequence available.
  genes <- genes[seqnames(genes) %in% seqnames(seqinfo(Dna))]

  ## Get the gene sequences, i.e. the sequence including the sequence of
  ## all of the gene's exons and introns.
  geneSeqs <- getSeq(Dna, genes)


#+END_SRC


To retrieve the (exonic) sequence of transcripts (i.e. without introns) we can
use directly the =extractTranscriptSeqs= method on the =EnsDb= object,
eventually using a filter to restrict the query. Alternatively, we could extract
the =GRanges= representing the exons of each transcript and use the =getSeq=
method.

#+BEGIN_SRC R :ravel eval=FALSE
  ## Extract the transcript sequences of all transcripts defined by Ensembl.
  txSeqs <- extractTranscriptSeqs(Dna, edb)


  ## Alternatively, use filters to restrict the search.
  yTx <- extractTranscriptSeqs(Dna, edb, filter=SeqnameFilter("Y"))

  ## Or extract first the exons by transcript and use the getSeq method.
  ## We're getting all exons by transcript for all genes defined by Ensembl. This
  ## excludes eventual "LRG" genes, that might be encoded on a sequence for which
  ## we don't have a DNA sequence.
  txExons <- exonsBy(edb, "tx", filter=GeneidFilter("ENS%", condition="like"))

  ## Extract the sequences of the first 10
  txSeqs <- lapply(txExons[1:10], function(x){unlist(getSeq(Dna, x))})

#+END_SRC


* Interactive annotation lookup using the =shiny= web app

In addition to the =genes=, =transcripts= and =exons= methods it is possibly to
search interactively for gene/transcript/exon annotations using the internal,
=shiny= based, web application. The application can be started with the
=runEnsDbApp()= function. The search results from this app can also be returned
to the R workspace either as a =data.frame= or =GRanges= object.


* Plotting gene/transcript features using =ensembldb= and =Gviz=

The =Gviz= package provides functions to plot genes and transcripts along with
other data on a genomic scale. Gene models can be provided either as a
=data.frame=, =GRanges=, =TxDB= database, can be fetched from biomart and can
also be retrieved from =ensembldb=.

Below we generate a =GeneRegionTrack= fetching all transcripts from a certain
region on chromosome Y.

Note that if we want in addition to work also with BAM files that were aligned
against DNA sequences retrieved from Ensembl or FASTA files representing genomic
DNA sequences from Ensembl we should change the
=ucscChromosomeNames= option from =Gviz= to =FALSE= (i.e. by calling
=options(ucscChromosomeNames = FALSE)=).
This is not necessary if we just want to retrieve gene models from an =EnsDb=
object, as the =ensembldb= package internally checks the =ucscChromosomeNames=
option and, depending on that, maps Ensembl chromosome names to UCSC chromosome
names.

#+BEGIN_SRC R :ravel gviz-plot, message=FALSE, fig.align='center', fig.width=7.5, fig.height=2.25
  ## Loading the Gviz library
  library(Gviz)
  library(EnsDb.Hsapiens.v75)
  edb <- EnsDb.Hsapiens.v75

  ## Retrieving a Gviz compatible GRanges object with all genes
  ## encoded on chromosome Y.
  gr <- getGeneRegionTrackForGviz(edb, chromosome="Y", start=20400000, end=21400000)
  ## Define a genome axis track
  gat <- GenomeAxisTrack()

  plotTracks(list(gat, GeneRegionTrack(gr)))

  ## Note: in some cases we might want to change the ucscChromosomeNames to FALSE
  ## i.e. using options(ucscChromosomeNames=FALSE) to force use of the chromosome names
  ## "as is", e.g. if we're also using and fetching genomic DNA information from Ensembl
  ## FASTA files or did align reads against Ensembl chromosome sequences.

#+END_SRC


We can also use the filters from the =ensembldb= package to further refine what
transcripts are fetched, like in the example below, in which we create two
different gene region tracks, one for protein coding genes and one for lincRNAs.

#+BEGIN_SRC R :ravel gviz-separate-tracks, message=FALSE, warning=FALSE, fig.align='center', fig.width=7.5, fig.height=2.25
  protCod <- getGeneRegionTrackForGviz(edb, chromosome="Y",
                                       start=20400000, end=21400000,
                                       filter=GenebiotypeFilter("protein_coding"))
  lincs <- getGeneRegionTrackForGviz(edb, chromosome="Y",
                                     start=20400000, end=21400000,
                                     filter=GenebiotypeFilter("lincRNA"))

  plotTracks(list(gat, GeneRegionTrack(protCod, name="protein coding"),
                  GeneRegionTrack(lincs, name="lincs")), transcriptAnnotation="symbol")
#+END_SRC

# Instead of using the =getGeneRegionTrackForGviz= we could also directly pass the
# =EnsDb= object to the =GeneRegionTrack=. In the example below we fetch also all
# transcripts of genes with biotypes other than /protein coding/ and /lincRNA/.

# #+BEGIN_SRC R :ravel gviz-separate-tracks-two, message=FALSE, warning=FALSE, fig.align='center', fig.width=7.5, fig.height=3
#   protGrt <- GeneRegionTrack(edb, chromosome="Y",
#                              start=20400000, end=21400000,
#                              filter=GenebiotypeFilter("protein_coding"),
#                              name="protein coding")
#   lincGrt <- GeneRegionTrack(edb, chromosome="Y",
#                              start=20400000, end=21400000,
#                              filter=GenebiotypeFilter("lincRNA"),
#                              name="lincRNA")
#   otherGrt <- GeneRegionTrack(edb, chromosome="Y",
#                              start=20400000, end=21400000,
#                              filter=GenebiotypeFilter(c("lincRNA", "protein_coding"),
#                                                       condition="!="),
#                              name="other")
#   plotTracks(list(gat, protGrt, lincGrt, otherGrt), transcriptAnnotation="symbol")

# #+END_SRC




* Important notes

These notes might explain eventually unexpected results (and, more importantly,
help avoiding them):

+ The ordering of the results returned by the =genes=, =exons=, =transcripts=
  methods can be specified with the =order.by= parameter. The ordering of the
  results does however *not* correspond to the ordering of values in submitted
  filter objects.

+ Results of =exonsBy=, =transcriptsBy= are always ordered by the =by= argument.


* Building an transcript centric database package based on Ensembl annotation

The code in this section is not supposed to be automatically executed when the
vignette is built, as this would require a working installation of the Ensembl
Perl API, which is not expected to be available on each system. Also, fetching
data from the Ensembl database takes quite some time, thus, in this section only
the code is displayed, but not executed.


** Requirements

The =fetchTablesFromEnsembl= function of the package uses the Ensembl Perl API
to retrieve the required annotations from an Ensembl database (e.g. from the
main site /ensembldb.ensembl.org/). Thus, to use the functionality to built
databases, the Ensembl Perl API needs to be installed (see [fn:2] for details).

Alternatively, the =ensDbFromGRanges= and =ensDbFromGtf= functions allow to
build EnsDb SQLite files from a =GRanges= object or an Ensembl GTF file and thus
doesn't depend on the Ensembl Perl API. Such =GRanges= objects could for example
be retrieved with the =AnnotationHub= package.


** Building an annotation package

The functions below use the Ensembl Perl API to fetch the required data directly
from the Ensembl core databases. Thus, the path to the Perl API specific for the
desired Ensembl version needs to be added to the =PERL5LIB= environment
variable.

An annotation package containing all human genes for Ensembl version 75 can be
created using the code in the block below.

#+BEGIN_SRC R :ravel eval=FALSE
  library(ensembldb)

  ## get all human gene/transcript/exon annotations from Ensembl (75)
  ## the resulting tables will be stored by default to the current working
  ## directory
  fetchTablesFromEnsembl(75, species="human")

  ## These tables can then be processed to generate a SQLite database
  ## containing the annotations (again, the function assumes the required
  ## txt files to be present in the current working directory)
  DBFile <- makeEnsemblSQLiteFromTables()

  ## and finally we can generate the package
  makeEnsembldbPackage(ensdb=DBFile, version="0.99.12",
                       maintainer="Johannes Rainer <johannes.rainer@eurac.edu>",
                       author="J Rainer")

#+END_SRC

The generated package can then be build using =R CMD build EnsDb.Hsapiens.v75=
and installed with =R CMD INSTALL EnsDb.Hsapiens.v75*=.  Note that we could
directly generate an =EnsDb= instance by loading the database file, i.e. by
calling =edb <- EnsDb(DBFile)= and work with that annotation object.

To fetch and build annotation packages for plant genomes (e.g. arabidopsis
thaliana), the /Ensembl genomes/ should be specified as a host, i.e. setting
=host= to ="mysql-eg-publicsql.ebi.ac.uk"=, =port= to =4157= and =species= to
e.g. ="arabidopsis thaliana"=.

In the next example we create an =EnsDb= database using the =AnnotationHub=
package and load also the corresponding genomic DNA sequence matching the
Ensembl version. We thus first query the =AnnotationHub= package for all
resources available for =Mus musculus= and the Ensembl release 77. Next we load
the =gtf= file for the transcript definitions and the =dna.toplevel.fa= file for
the DNA sequence. From the =GRanges= object representing the =gtf= file we can
build and load an =EnsDb=. At last we retrieve the sequences of all exons using
the =getSeq= method.

#+BEGIN_SRC R :ravel eval=FALSE
  ## load the AnnotationHub data
  library(AnnotationHub)
  ah <- AnnotationHub()

  ## query all available files from Ensembl release 77 for
  ## Mus musculus
  query(ah, c("Mus musculus", "release-77"))

  ## get the gtf file
  Gtf <- ah[["AH28822"]]
  ## create a EnsDb database file from the Gtf
  DbFile <- ensDbFromGRanges(Gtf, organism="Mus_musculus", version=77)
  ## we can either generate a database package, or directly load the data
  Edb <- EnsDb(DbFile)

  ## retrieve the toplevel DNA
  Dna <- ah[["AH22042"]]

  ## we next retrieve the sequence of all exons
  library(Rsamtools)
  exons <- exons(Edb)
  exonSeq <- getSeq(Dna, exons)

#+END_SRC

In the example below we load a =GRanges= containing gene definitions for genes
encoded on chromosome Y and generate a EnsDb SQLite database from that
information.

#+BEGIN_SRC R
  ## Generate a sqlite database from a GRanges object specifying
  ## genes encoded on chromosome Y
  load(system.file("YGRanges.RData", package="ensembldb"))
  Y

  DB <- ensDbFromGRanges(Y, path=tempdir(), version=75,
			 organism="Homo_sapiens")

  edb <- EnsDb(DB)
  edb

  ## As shown in the example below, we could make an EnsDb package on
  ## this DB object using the makeEnsembldbPackage function.

#+END_SRC


Alternatively we can build the annotation database using the =ensDbFromGtf=
function, that extracts most of the required data from a GTF file which can be
downloaded from Ensembl (e.g. from
ftp://ftp.ensembl.org/pub/release-75/gtf/homo_sapiens for human gene definitions
from Ensembl version 75; for plant genomes etc files can be retrieved from
ftp://ftp.ensemblgenomes.org). All information except the chromosome lengths and
the NCBI Entrezgene IDs can be extracted from these GTF files. The function also
tries to retrieve chromosome length information automatically from Ensembl.

Below we create the annotation from a gtf file that we fetch directly from Ensembl.

#+BEGIN_SRC R :ravel eval=FALSE
  library(ensembldb)

  ## the GTF file can be downloaded from
  ## ftp://ftp.ensembl.org/pub/release-75/gtf/homo_sapiens/
  gtffile <- "Homo_sapiens.GRCh37.75.gtf.gz"
  ## generate the SQLite database file
  DB <- ensDbFromGtf(gtf=gtffile, verbose=TRUE)

  ## load the DB file directly
  EDB <- EnsDb(DB)

  ## alternatively, build the annotation package
  ## and finally we can generate the package
  makeEnsembldbPackage(ensdb=DB, version="0.99.12",
                       maintainer="Johannes Rainer <johannes.rainer@eurac.edu>",
                       author="J Rainer")

#+END_SRC


* Database layout<<section.database.layout>>

The database consists of the following tables and attributes (the layout is also
shown in Figure [[fig.database.layout]]):

+ *gene*: all gene specific annotations.
  - =gene_id=: the Ensembl ID of the gene.
  - =gene_name=: the name (symbol) of the gene.
  - =entrezid=: the NCBI Entrezgene ID(s) of the gene. Note that this can be a
    =;= separated list of IDs for genes that are mapped to more than one
    Entrezgene.
  - =gene_biotype=: the biotype of the gene.
  - =gene_seq_start=: the start coordinate of the gene on the sequence (usually
    a chromosome).
  - =gene_seq_end=: the end coordinate of the gene on the sequence.
  - =seq_name=: the name of the sequence (usually the chromosome name).
  - =seq_strand=: the strand on which the gene is encoded.
  - =seq_coord_system=: the coordinate system of the sequence.

+ *tx*: all transcript related annotations.
  - =tx_id=: the Ensembl transcript ID.
  - =tx_biotype=: the biotype of the transcript.
  - =tx_seq_start=: the start coordinate of the transcript.
  - =tx_seq_end=: the end coordinate of the transcript.
  - =tx_cds_seq_start=: the start coordinate of the coding region of the
    transcript (NULL for non-coding transcripts).
  - =tx_cds_seq_end=: the end coordinate of the coding region of the transcript.
  - =gene_id=: the gene to which the transcript belongs.

+ *exon*: all exon related annotation.
  - =exon_id=: the Ensembl exon ID.
  - =exon_seq_start=: the start coordinate of the exon.
  - =exon_seq_end=: the end coordinate of the exon.

+ *tx2exon*: provides the n:m mapping between transcripts and exons.
  - =tx_id=: the Ensembl transcript ID.
  - =exon_id=: the Ensembl exon ID.
  - =exon_idx=: the index of the exon in the corresponding transcript, always
    from 5' to 3' of the transcript.

+ *chromosome*: provides some information about the chromosomes.
  - =seq_name=: the name of the sequence/chromosome.
  - =seq_length=: the length of the sequence.
  - =is_circular=: whether the sequence in circular.

+ *information*: some additional, internal, informations (Genome build, Ensembl
  version etc).
  - =key=
  - =value=

#+ATTR_LATEX: :center :placement [h!] :width 14cm
#+NAME: fig.database.layout
#+CAPTION: Database layout.
[[file:images/dblayout.png]]



* Footnotes

[fn:1] http://www.ensembl.org

[fn:2] http://www.ensembl.org/info/docs/api/api_installation.html

[fn:3] http://www.lrg-sequence.org

[fn:4] http://www.ncbi.nlm.nih.gov/pubmed/23950696

[fn:5] http://www.ncbi.nlm.nih.gov/pubmed/24227677


* TODOs								   :noexport:

** DONE Fix the =ensembldb:::EnsDb= call in /zzz.R/ of the package template!
   CLOSED: [2015-04-01 Wed 12:05]
   - State "DONE"       from "TODO"       [2015-04-01 Wed 12:05]

The =EnsDb= construction function is exported, thus there is no need for the =:::=.

** DONE Implement the =distjointExons= method.
   CLOSED: [2015-03-25 Wed 09:43]
   - State "DONE"       from "TODO"       [2015-03-25 Wed 09:43]
** DONE Fix return value for =organism=
   CLOSED: [2015-03-27 Fri 12:10]
   - State "DONE"       from "TODO"       [2015-03-27 Fri 12:10]

The return value should be /Genus species/, i.e. without =_= in between.
** DONE Check =utils::news=, =?news=
   CLOSED: [2015-04-02 Thu 08:50]
   - State "DONE"       from "TODO"       [2015-04-02 Thu 08:50]
** DONE build the database based on an Ensembl gtf file
   CLOSED: [2015-04-10 Fri 07:02]
   - State "DONE"       from "TODO"       [2015-04-10 Fri 07:02]
   - That would be the pre-requisite to write recipes for the =AnnotationHub= package.
   - The only missing data is the sequence lengths.
** DONE Use the =GenomicFeatures= =fetchChromLengthsFromEnsembl= to retrieve chromosome lengths for GTF import
   CLOSED: [2015-04-14 Tue 11:36]
   - State "DONE"       from "TODO"       [2015-04-14 Tue 11:36]

+ Ideally, automatically run this script, if there is any error just skip, but do not stop. To do that, use the =try= call.

** CANCELED Include recipe to =AnnotationHub=
   CLOSED: [2015-06-12 Fri 08:55]
   - State "CANCELED"   from "TODO"       [2015-06-12 Fri 08:55] \\
     Don't need that really. We can retrieve the GRanges object and build the EnsDb object or package based on that.
** CANCELED Implement a function to /guess/ the correct BSgenome package
   CLOSED: [2015-06-11 Thu 08:45]
   - State "CANCELED"   from "TODO"       [2015-06-11 Thu 08:45] \\
     Drop that; better to fetch the sequence from AnnotationHub!
+ In the end it seems I have to do some hard-coding there...


** DONE Implement a function to load the appropriate DNA sequence from AnnotationHub
   CLOSED: [2015-06-12 Fri 08:55]
   - State "DONE"       from "TODO"       [2015-06-12 Fri 08:55]
+ [X] Implement a method to retrieve the Ensembl version.
Some code snippet:
=query(ah, c(organism(edb), paste0("release-")))= and use =mcols()= on the result to search for =dna.toplevel.fa=.

** DONE Implement a function to build an EnsDb from a GRanges object.
   CLOSED: [2015-04-14 Tue 11:35]
   - State "DONE"       from "TODO"       [2015-04-14 Tue 11:35]
** DONE Implement the =cdsBy= method.
   CLOSED: [2015-10-30 Fri 09:15]
   - State "DONE"       from "TODO"       [2015-10-30 Fri 09:15]
This has to be implemented for =by= being ="tx"= and ="gene"=. Note that we can
*only* return this stuff for protein coding genes!!!
For =tx=:
- returns the exons constituting the cds. Returns a =GRangesList= with =GRanges=
  and metadata columns: =cds_id=, =cds_name=, =exon_rank=. The latter is clear,
  the other two are ?
- option =use.names= will return the TX ID.

For =gene=:
- Could we get that using =reduce=?

** DONE Implement the =fiveUTRsByTranscript= method.
   CLOSED: [2015-10-30 Fri 15:05]
   - State "DONE"       from "TODO"       [2015-10-30 Fri 15:05]


** DONE Implement the =threeUTRsByTranscript= method.
   CLOSED: [2015-10-30 Fri 15:05]
   - State "DONE"       from "TODO"       [2015-10-30 Fri 15:05]
** DONE Implement a method to use ensembldb for =Gviz=
   CLOSED: [2015-11-04 Wed 09:15]
   - State "DONE"       from "TODO"       [2015-11-04 Wed 09:15]
Do something similar to the .buildRange method for "TxDb" objects
(/Gviz-methods.R/). Ideally, the function should return a =GRanges= object (or
might a =data.frame= do as well?).

+ Implement a method that builds a =data.frame= for =Gviz=.
+ Check =.getBiotypeColor= function in /Gviz.R/ line 681.
+ Check =GeneRegionTrack= constructor in /AllClasses.R/, line 897 ->
  =.buildRanges= ()
+ =getGeneRegionTrackForGviz= should ideally return a =GRanges=, setting also
  the genome, seqinfo etc.
** WAIT Add a section in the vignette describing the use of =Gviz= with =ensembldb=
   - State "WAIT"       from "TODO"       [2015-11-06 Fri 08:41] \\
     Wait for Florian Hahne to add the changes to Gviz.


** DONE Implement a fix that would allow UCSC chromosome names [4/4]
   CLOSED: [2015-11-30 Mon 09:24]
   - State "DONE"       from "TODO"       [2015-11-30 Mon 09:24]
The idea is that, reading =options("ucscChromosomeNames")= a ="chr"= is appended
to the chromosome names. That way, =EnsDb= databases could directly work with
=Gviz= (as that package uses the above option).

+ If something is queried from the database, the ="chr"= has to be stripped
  off. Here we have to deal with the filters:
+ [X] =SeqnameFilter=: this now always returns stripped chr names, if =EnsDb= is
  also submitted.
+ [X] =GRangesFilter=
  and eventually using their =value= method:
+ If anything is returned from the database, a ="chr"= has to be appended, if
  the options are =TRUE=.
  - Looks like the major return path is =getWhat=, so, will include the replace
    stuff there.
+ [X] Adapt =getWhat=.
+ [X] The query to build the Gviz =GenePanel=.

** DONE Implement a fix to rename additional chromosome names, like =Mt= etc.
   CLOSED: [2015-11-30 Mon 08:59]
   - State "DONE"       from "TODO"       [2015-11-30 Mon 08:59]
** DONE Implement a =GRangesFilter= [2/2]
   CLOSED: [2015-11-27 Fri 13:59]
   - State "DONE"       from "TODO"       [2015-11-27 Fri 13:59]
+ [X] Filter should allow to either get all features =within= the GRanges:
  complete feature has to be within the range.
+ [X] All features overlapping: =overlappingExon=: part of an exon has to
  overlap the range. =overlappingAll=: exon or intron has to partially overlap
  the range.

+ Filter should use the coordinates of the things to fetch, i.e. gene,
  transcript or exon regions.

+ =within=: _seq_start >= start & _seq_end <= end.
+ =overlapping=: _seq_start <= end & _seq_end >= start.
** TODO Extend the =getGenomeFaFile= method

Search for the genome release matching the current Ensembl release, if not
present, search for a (Ensembl) =FaFile= matching the genome version and, if
more available, select the one with the closest release date or version.

** TODO Interface to the =OrganismDbi= database.
** DONE Enhance the shiny app to return the search result.
   CLOSED: [2015-12-21 Mon 14:52]
   - State "DONE"       from "TODO"       [2015-12-21 Mon 14:52]
